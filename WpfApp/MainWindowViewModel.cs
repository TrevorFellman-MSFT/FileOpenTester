using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using Microsoft.Win32;
using Prism.Commands;
using Prism.Mvvm;

namespace WpfApp
{
    public class MainWindowViewModel : BindableBase
    {
        public enum OpenModes
        {
            Open,
            OpenRead
        }

        public enum ReadModes
        {
            UiThread,
            BackgroundThread,
            ReadAsync
        }

        public enum TempCopyModes
        {
            Detect,
            NoCopy,
            ForceCopy
        }

        private bool _CopyInProgress;

        private string _DebugLog = "";

        private FileAccess _FileAccessMode = FileAccess.Read;

        private FileShare _FileShareMode = FileShare.Read;

        private string _Path;

        private double _Progress;

        private int _ReadBufferSize = 650000;

        private ReadModes _ReadMode = ReadModes.UiThread;

        private Stopwatch _Sw = new Stopwatch();

        private TempCopyModes _TempMode = TempCopyModes.Detect;

        private string _TempPath;

        public MainWindowViewModel()
        {
            BrowseCommand = new DelegateCommand(Browse);
            TempBrowseCommand = new DelegateCommand(TempBrowse);
            CancelCommand = new DelegateCommand(Cancel);
            OpenCommand = new DelegateCommand(Open, CanOpen);
        }

        public DelegateCommand BrowseCommand { get; }

        public DelegateCommand OpenCommand { get; }

        public DelegateCommand CancelCommand { get; }

        public bool CopyInProgress
        {
            get => _CopyInProgress;
            set => SetProperty(ref _CopyInProgress, value);
        }

        public string DebugLog
        {
            get => _DebugLog;
            set => SetProperty(ref _DebugLog, value);
        }

        public List<FileAccess> FileAccessList { get; } = new List<FileAccess> {FileAccess.Read, FileAccess.Write};

        public FileAccess FileAccessMode
        {
            get => _FileAccessMode;
            set => SetProperty(ref _FileAccessMode, value);
        }

        public FileShare FileShareMode
        {
            get => _FileShareMode;
            set => SetProperty(ref _FileShareMode, value);
        }

        public List<FileShare> FileShareModesList { get; } = new List<FileShare>
            {FileShare.Read, FileShare.ReadWrite, FileShare.None};


        public string Path
        {
            get => _Path;
            set
            {
                SetProperty(ref _Path, value);
                OpenCommand.RaiseCanExecuteChanged();
            }
        }

        public double Progress
        {
            get => _Progress;
            set => SetProperty(ref _Progress, value);
        }

        public int ReadBufferSize
        {
            get => _ReadBufferSize;
            set => SetProperty(ref _ReadBufferSize, value);
        }

        public ReadModes ReadMode
        {
            get => _ReadMode;
            set => SetProperty(ref _ReadMode, value);
        }

        public List<ReadModes> ReadModesList { get; } = new List<ReadModes>
            {ReadModes.UiThread, ReadModes.BackgroundThread, ReadModes.ReadAsync};

        public ICommand TempBrowseCommand { get; }

        public List<TempCopyModes> TempCopyModesList { get; } = new List<TempCopyModes>
            {TempCopyModes.Detect, TempCopyModes.NoCopy, TempCopyModes.ForceCopy};

        public TempCopyModes TempMode
        {
            get => _TempMode;
            set => SetProperty(ref _TempMode, value);
        }

        public string TempPath
        {
            get => _TempPath;
            set => SetProperty(ref _TempPath, value);
        }

        private bool CancellationRequested { get; set; }

        public void Browse()
        {
            var fd = new OpenFileDialog();
            fd.ShowDialog();
            Path = fd.FileName;
        }

        public bool CanOpen()
        {
            return File.Exists(_Path) && !CopyInProgress;
        }

        public void Open()
        {
            OpenImpl();
        }

        public async Task OpenImpl()
        {
            CopyInProgress = true;
            CancellationRequested = false;

            var path = Path;
            var fi = new FileInfo(path);

            var sw = new Stopwatch();
            sw.Start();

            ///////////////////////////////////////////////
            ///Copy If Needed

            if (ShouldCopyToTemp())
            {
                path = System.IO.Path.Combine(TempPath, fi.Name);

                if (File.Exists(path))
                {
                    var result = MessageBox.Show($"Temp File Exists, Delete it?\r\n\r\n{path}", "",
                        MessageBoxButton.YesNoCancel);
                    if (result == MessageBoxResult.Yes)
                    {
                        DebugLog += $"Deleted File ({path})\r\n";
                        await Task.Run(() => File.Delete(path));
                    }

                    if (result == MessageBoxResult.Cancel)
                    {
                        DebugLog += string.Format("Operation Canceled)\r\n", path);
                        return;
                    }
                }

                DebugLog += $"Copying File To Temp ({Path} to {TempPath})";

                await Task.Run(() => File.Copy(Path, path));

                DebugLog += $"took {sw.Elapsed.TotalSeconds}s\r\n";

                fi = new FileInfo(path);
            }

            sw.Restart();

            DebugLog += $"Reading File {fi.FullName} ({fi.Length / (1024 * 1024)}MB)";

            /////////////////////////////////////////////
            // Open and Read File

            if (ReadMode == ReadModes.BackgroundThread)
                await Task.Run(() => ReadFile(path, SynchronizationContext.Current));
            else
                await ReadFile(path, null);

            sw.Stop();

            CopyInProgress = false;

            DebugLog += $"took {sw.Elapsed.TotalSeconds}s\r\n";
        }

        public void TempBrowse()
        {
            OpenFileDialog fd;
            fd = new OpenFileDialog
            {
                ValidateNames = false,
                CheckFileExists = false,
                CheckPathExists = true,
                FileName = "Folder Selection"
            };
            fd.ShowDialog();
            TempPath = fd.FileName.Replace("Folder Selection", "");
        }

        [DllImport("shlwapi.dll")]
        private static extern bool PathIsNetworkPath(string pszPath);

        private void Cancel()
        {
            CancellationRequested = true;
            DebugLog += "Read Canceled\r\n";
        }

        private FileStream OpenFile(string path)
        {
            DebugLog += $"FileAccessMode=({FileAccessMode}, FileShareMode=({FileShareMode}, ReadMode=({ReadMode})\r\n";

            //return File.Open(path);

            return new FileStream(path, FileMode.Open, FileAccessMode, FileShareMode, ReadBufferSize);

        }

        private async Task ReadFile(string path, SynchronizationContext synchronizationContext)
        {
            var fi = new FileInfo(path);

            var swUpdate = new Stopwatch();
            swUpdate.Start();

            using (var fs = OpenFile(path))
            {
                var b = new byte[ReadBufferSize]; //65k
                var temp = new UTF8Encoding(true);

                if (ReadMode == ReadModes.ReadAsync)
                {
                    while (await fs.ReadAsync(b, 0, b.Length) > 0 && !CancellationRequested)
                        if (swUpdate.ElapsedMilliseconds > 1000)
                        {
                            swUpdate.Restart();
                            UpdateProgress(fs, synchronizationContext);
                        }
                }
                else
                {
                    while (fs.Read(b, 0, b.Length) > 0 && !CancellationRequested)
                        if (swUpdate.ElapsedMilliseconds > 1000)
                        {
                            swUpdate.Restart();
                            UpdateProgress(fs, synchronizationContext);
                        }
                }
            }
        }

        private bool ShouldCopyToTemp()
        {
            return Directory.Exists(TempPath) &&
                   (TempMode == TempCopyModes.Detect && PathIsNetworkPath(Path) ||
                    TempMode == TempCopyModes.ForceCopy);
        }

        private void UpdateProgress(FileStream fs, SynchronizationContext synchronizationContext)
        {
            var progress = fs.Position / (double) fs.Length;

            if (null != synchronizationContext)
                synchronizationContext.Post(o => Progress = progress, this);
            else
                Progress = progress;
        }
    }
}